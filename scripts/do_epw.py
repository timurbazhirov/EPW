#!/usr/bin/env python
#
# Script for running EPW. sinisacoh@gmail.com
# Do not edit this file to change job parameters. Instead change loc.py
#

import sys # for system stuff
import os  #
import subprocess as sub #
import loc # parameters for the calculation
import xml.dom.minidom # reading xml
import numpy as np # for numerics
import datetime # needed for timestamps

# get executables from the submission script
PH_SCF_EXEC  =sub.Popen("echo $PH_SCF_EXEC  ", shell=True,stdout=sub.PIPE).communicate()[0].strip()
PH_NSCF_EXEC =sub.Popen("echo $PH_NSCF_EXEC ", shell=True,stdout=sub.PIPE).communicate()[0].strip()
PH_PH_EXEC   =sub.Popen("echo $PH_PH_EXEC   ", shell=True,stdout=sub.PIPE).communicate()[0].strip()
EPW_NSCF_EXEC=sub.Popen("echo $EPW_NSCF_EXEC", shell=True,stdout=sub.PIPE).communicate()[0].strip()
EPW_EPW_EXEC =sub.Popen("echo $EPW_EPW_EXEC  ", shell=True,stdout=sub.PIPE).communicate()[0].strip()

def main():
    legend()
    exec_info()
    
    # parse arguments
    #
    # do all calculations at once
    if len(sys.argv)==1:
        if os.path.exists("run/01")==False:
            os.popen("mkdir run/01")
            do_scf()
        else:
            print "Skipping step run/01"
        if os.path.exists("run/02")==False:
            os.popen("mkdir run/02")
        do_phonons()
        if os.path.exists("run/03")==False:
            os.popen("mkdir run/03")
            do_nscf_for_epw()
        else:
            print "Skipping step run/03"
        if os.path.exists("run/04")==False:
            os.popen("mkdir run/04")
            do_epw_first()
        else:
            print "Skipping step run/04"
        if os.path.exists("run/05")==False:
            os.popen("mkdir run/05")
            do_epw_second()
        else:
            print "Skipping step run/05"        
    # only do scf calculation
    elif len(sys.argv)==2:
        if sys.argv[1]=="scf":
            if os.path.exists("run/01")==False:
                os.popen("mkdir run/01")
                do_scf()
            else:
                print "Skipping step run/01"
        else:
            help()
            sys.exit(1)
    # only do one phonon calculation
    elif len(sys.argv)==3:
        if sys.argv[1]=="ph_one":
            if os.path.exists("run/02")==False:
                os.popen("mkdir run/02")
            do_phonons(only_one_phonon=True,one_phonon_argv=sys.argv[2])
        else:
            help()
            sys.exit(1)
    else:
        help()
        sys.exit(1)
        
def do_scf():
    # make input file for the SCF run
    f=open("run/01/scf.in","w")
    f.write("&control\n")
    f.write("calculation='scf'\n")
    f.write("prefix='pref'\n")
    f.write("outdir='_work'\n")
    f.write("wf_collect=true\n")
    f.write(loc.BLOCKS["control"].strip()+"\n")
    f.write("/\n")
    f.write("&system\n")
    f.write(loc.BLOCKS["system"].strip()+"\n")
    f.write("/\n")
    f.write("&electrons\n")
    f.write(loc.BLOCKS["electrons"].strip()+"\n")
    f.write("/\n")
    f.write("ATOMIC_SPECIES\n")
    f.write(loc.BLOCKS["ATOMIC_SPECIES"].strip()+"\n")
    f.write("ATOMIC_POSITIONS crystal\n")
    f.write(loc.BLOCKS["atomic_positions_crystal"].strip()+"\n")
    f.write("K_POINTS automatic\n")
    f.write(str(loc.KMESH[0])+" "+str(loc.KMESH[1])+" "+str(loc.KMESH[2])+"  0 0 0 \n")
    f.write("CELL_PARAMETERS alat\n")
    f.write(loc.BLOCKS["cell_parameters_alat"].strip()+"\n")
    f.close()

    # create scratch folder
    os.popen("mkdir run/01/_work")
    # run QE
    os.popen("cd run/01 ; "+PH_SCF_EXEC+" -in scf.in &> scf.out")
    # clean up wavefunctions and stuff
    os.popen("cd run/01 ; rm _work/*")

    # find q-vectors used in the scf run, and to be used in phonon run
    (numq,phonon_qpts,phonon_weights)=get_kpoints_weights("run/01/_work/pref.save/data-file.xml")
    f=open("_phonon_list","w")
    f.write(np.array_str(phonon_qpts,precision=15)+"\n")
    f.close()
    
def do_phonons(only_one_phonon=False,one_phonon_argv=None):
    # create folders in which all dvscf and dyn files will be stored
    if os.path.exists("run/02/save")==False:
        os.popen("mkdir run/02/save")
    # get phonon qpoints and weights 
    (numq,phonon_qpts,phonon_weights)=get_kpoints_weights("run/01/_work/pref.save/data-file.xml")
    # run all qpoints one after the other
    if only_one_phonon==False:
        for ph_index in range(numq):
            run_one_phonon(ph_index,numq,phonon_qpts)
    else:
        # do only one phonon
        #  get phonon index
        ph_index=int(one_phonon_argv)
        if ph_index<1 or ph_index>numq:
            print "Phonon index out of range! ",one_phonon_argv
            sys.exit(1)
        run_one_phonon(ph_index-1,numq,phonon_qpts)
        
def run_one_phonon(ph_index,numq,phonon_qpts):
    "Do one phonon calculation"
    # number of digits used for qpoint integer
    num_dig=len(str(numq+1))
    # subfolder name for this qpoint
    subf=str(ph_index+1).zfill(num_dig)
    # skip calculations that are done already
    if os.path.exists("run/02/q"+subf)==False:
        # make temporary folder, rename it if calculation finishes sucessfully
        os.popen("mkdir run/02/,q"+subf)
        # make input file for the NSCF run
        f=open("run/02/,q"+subf+"/nscf.in","w")
        f.write("&control\n")
        f.write("calculation='phonon'\n")
        f.write("prefix='pref'\n")
        f.write("outdir='_work'\n")
        f.write("wf_collect=true\n")
        f.write(loc.BLOCKS["control"].strip()+"\n")
        f.write("/\n")
        f.write("&system\n")
        f.write(loc.BLOCKS["system"].strip()+"\n")
        f.write("/\n")
        f.write("&electrons\n")
        f.write(loc.BLOCKS["electrons"].strip()+"\n")
        f.write("/\n")
        f.write("&phonon\n")
        f.write("xqq(1) = "+'%.15f'%phonon_qpts[ph_index,0]+"\n")
        f.write("xqq(2) = "+'%.15f'%phonon_qpts[ph_index,1]+"\n")
        f.write("xqq(3) = "+'%.15f'%phonon_qpts[ph_index,2]+"\n")
        f.write("/\n")
        f.write("ATOMIC_SPECIES\n")
        f.write(loc.BLOCKS["ATOMIC_SPECIES"].strip()+"\n")
        f.write("ATOMIC_POSITIONS crystal\n")
        f.write(loc.BLOCKS["atomic_positions_crystal"].strip()+"\n")
        f.write("K_POINTS automatic\n")
        f.write(str(loc.KMESH[0])+" "+str(loc.KMESH[1])+" "+str(loc.KMESH[2])+"  0 0 0 \n")
        f.write("CELL_PARAMETERS alat\n")
        f.write(loc.BLOCKS["cell_parameters_alat"].strip()+"\n")
        f.close()
        # make input file for the PH run
        f=open("run/02/,q"+subf+"/ph.in","w")
        f.write("--\n")
        f.write("&inputph\n")
        f.write(loc.BLOCKS["inputph"].strip()+"\n")
        f.write("prefix   = 'pref'\n")
        f.write("outdir   = '_work'\n")
        f.write("fildyn   = 'pref.dyn'\n")
        f.write("fildvscf = 'dvscf'\n")
        f.write("/\n")
        f.write('%.15f'%phonon_qpts[ph_index,0]+"  ")
        f.write('%.15f'%phonon_qpts[ph_index,1]+"  ")
        f.write('%.15f'%phonon_qpts[ph_index,2])
        f.close()
        
        # create scratch folder
        os.popen("mkdir run/02/,q"+subf+"/_work")
        # copy density from the scf run
        os.popen("cp -rf run/01/_work/* run/02/,q"+subf+"/_work/")
        # run NSCF
        proc_a=sub.Popen("cd run/02/,q"+subf+" ; "+PH_NSCF_EXEC+" -in nscf.in &> nscf.out",shell=True)
        proc_a.wait()
        if proc_a.returncode!=0:
            print "Failed nscf run for phonon folder: ",subf
            os.popen("mv run/02/,q"+subf+" run/02/,q"+subf+"__FAILED_NSCF")
            sys.exit(1)
        # run PH
        proc_b=sub.Popen("cd run/02/,q"+subf+" ; "+PH_PH_EXEC+" -in ph.in &> ph.out",shell=True)
        proc_b.wait()
        if proc_b.returncode!=0:
            print "Failed ph run for phonon folder: ",subf
            os.popen("mv run/02/,q"+subf+" run/02/,q"+subf+"__FAILED_PH")
            sys.exit(1)
            
        # move dyn and dvscf files to another folder
        os.popen("mv run/02/,q"+subf+"/pref.dyn run/02/save/pref.dyn_q"+subf)
        # dvscf file names are inconsistently named in quantum espresso
        # it seems to depend on the number of cpus used or number of pools?
        for ext in ["1","01","001","0001"]:
            fnm_tmp="mv run/02/,q"+subf+"/_work/pref.dvscf"+ext
            if os.path.exists(fnm_tmp)==True:
                os.popen("mv "+fnm_tmp+" run/02/save/pref.dvscf_q"+subf)
        # clean up wavefunctions and stuff
        #os.popen("cd run/02/,q"+subf+" ; "+"rm _work/*")

        # rename phonon folder now that everything is succesfully run
        os.popen("mv run/02/,q"+subf+" run/02/q"+subf)
    else:
        print "Skippping phonon calculation run/02/q"+subf
        
def do_nscf_for_epw():
    # do nscf run without symmetries but with only one iteration
    # use this only to get a kmesh
    # after that do a second run
    for s in range(2):
        # run only to get kmesh
        if s==0:
            os.popen("mkdir run/03/get_mesh")
            f=open("run/03/get_mesh/nscf.in","w")
        # real nscf run
        elif s==1:
            f=open("run/03/nscf.in","w")
        f.write("&control\n")
        f.write("calculation='nscf'\n")
        f.write("prefix='pref'\n")
        f.write("outdir='_work'\n")
        f.write("wf_collect=true\n")
        f.write(loc.BLOCKS["control"].strip()+"\n")
        f.write("/\n")
        f.write("&system\n")
        f.write(loc.BLOCKS["system"].strip()+"\n")
        f.write("nosym=true\n")
        f.write("noinv=true\n")
        f.write("/\n")
        f.write("&electrons\n")
        f.write(loc.BLOCKS["electrons"].strip()+"\n")
        if s==0:
            f.write("electron_maxstep=0\n")
        f.write("/\n")
        f.write("ATOMIC_SPECIES\n")
        f.write(loc.BLOCKS["ATOMIC_SPECIES"].strip()+"\n")
        f.write("ATOMIC_POSITIONS crystal\n")
        f.write(loc.BLOCKS["atomic_positions_crystal"].strip()+"\n")
        if s==0:
            # use automatic grid (this is not necesasrily in reduced coordinates from 0 to 1)
            f.write("K_POINTS automatic\n")
            f.write(str(loc.KMESH[0])+" "+str(loc.KMESH[1])+" "+str(loc.KMESH[2])+"  0 0 0 \n")
        if s==1:
            # use grid that in reduced coordinates would be from 0 to 1
            # this is needed in EPW!
            f.write("K_POINTS alat\n")
            f.write(str(numk)+"\n")
            for i in range(numk):
                for j in range(3):
                    f.write('%.15f'%kpts[i,j]+" ")
                f.write("    "+'%.15f'%kpt_weights[i]+"\n")
        f.write("CELL_PARAMETERS alat\n")
        f.write(loc.BLOCKS["cell_parameters_alat"].strip()+"\n")
        f.close()
        
        if s==0:
            # create scratch folder
            os.popen("mkdir run/03/get_mesh/_work")
            # copy density from the scf run
            os.popen("cp -rf run/01/_work/* run/03/get_mesh/_work/")
            # run NSCF
            os.popen("cd run/03/get_mesh ; "+EPW_NSCF_EXEC+" -in nscf.in &> nscf.out")
            # clean up wavefunctions and stuff
            os.popen("cd run/03/get_mesh ; "+"rm _work/*")
            # get kpoints and put them in the home cell
            (numk,kpts,kpt_weights)=get_kpoints_weights("run/03/get_mesh/_work/pref.save/data-file.xml")
        elif s==1:
            # create scratch folder
            os.popen("mkdir run/03/_work")
            # copy density from the scf run
            os.popen("cp -rf run/01/_work/* run/03/_work/")
            # run NSCF
            os.popen("cd run/03 ; "+EPW_NSCF_EXEC+" -in nscf.in &> nscf.out")

def do_epw_first():
    "Do EPW calculation but without explicit lambda, a2f or whatever calculation"
    # find q-vectors used in the scf run, and to be used in phonon run
    (numq,phonon_qpts,phonon_weights)=get_kpoints_weights("run/01/_work/pref.save/data-file.xml")
    # make input file for the first EPW run
    f=open("run/04/epw.in","w")
    f.write("--\n")
    f.write("&inputepw\n")
    f.write(loc.BLOCKS["inputepw"].strip()+"\n")
    f.write(\
"""
  prefix      = 'pref',
  outdir      = '_work/'
  elph        = .true.
  kmaps       = .false.
  epbwrite    = .true.
  epbread     = .false.
  epwwrite    = .true.
  epwread     = .false.
  epf_mem     = .true.
  etf_mem     = .true.
  wannierize  = .true.
  elinterp    = .true.
  phinterp    = .true.
  tshuffle2   = .true.
  tphases     = .false.
  fly         = .true.
  parallel_k  = .true.
  parallel_q  = .false.
  dvscf_dir   = '../02/save'
  nk1         = """+str(loc.KMESH[0])+"""
  nk2         = """+str(loc.KMESH[1])+"""
  nk3         = """+str(loc.KMESH[2])+"""
  nq1         = """+str(loc.KMESH[0])+"""
  nq2         = """+str(loc.KMESH[1])+"""
  nq3         = """+str(loc.KMESH[2])+"""
  nqf1 = 1
  nqf2 = 1
  nqf3 = 1
  nkf1 = 1
  nkf2 = 1
  nkf3 = 1
 /
""")
    f.write(str(numq)+"  cartesian\n")
    for i in range(numq):
        for j in range(3):
            f.write('%.15f'%phonon_qpts[i,j]+" ")
        f.write("    "+'%.15f'%phonon_weights[i]+"\n")
    f.close()
    
    # use scratch folder from case 03
    if os.path.exists("run/04/_work")==False:
        os.popen("cd run/04 ; ln -s ../03/_work .")
    # run EPW
    os.popen("cd run/04; "+EPW_EPW_EXEC+" -in epw.in &> epw.out")
    # clean up some large files used in EPW
    os.popen("cd run/04 ; rm _work/pref.epmatwe*")
    os.popen("cd run/04 ; rm _work/pref.epmatwp*")

def do_epw_second():
    "Do EPW calculation but only for lambda, a2f or whatever calculation"
    # find q-vectors used in the scf run, and to be used in phonon run
    (numq,phonon_qpts,phonon_weights)=get_kpoints_weights("run/01/_work/pref.save/data-file.xml")
    # make input file for the first EPW run
    f=open("run/05/epw.in","w")
    f.write("--\n")
    f.write("&inputepw\n")
    f.write(loc.BLOCKS["inputepw"].strip()+"\n")
    f.write(loc.EPW_SECOND_RUN.strip()+"\n")
    f.write(\
"""
  prefix      = 'pref',
  outdir      = '_work/'
  elph        = .true.
  kmaps       = .true.
  epbwrite    = .false.
  epbread     = .true.
  epwwrite    = .false.
  epwread     = .true.
  epf_mem     = .true.
  etf_mem     = .true.
  wannierize  = .false.
  elinterp    = .true.
  phinterp    = .true.
  tshuffle2   = .true.
  tphases     = .false.
  fly         = .true.
  parallel_k  = .true.
  parallel_q  = .false.
  dvscf_dir   = '../02/save'
  nk1         = """+str(loc.KMESH[0])+"""
  nk2         = """+str(loc.KMESH[1])+"""
  nk3         = """+str(loc.KMESH[2])+"""
  nq1         = """+str(loc.KMESH[0])+"""
  nq2         = """+str(loc.KMESH[1])+"""
  nq3         = """+str(loc.KMESH[2])+"""
 /
""")
    f.write(str(numq)+"  cartesian\n")
    for i in range(numq):
        for j in range(3):
            f.write('%.15f'%phonon_qpts[i,j]+" ")
        f.write("    "+'%.15f'%phonon_weights[i]+"\n")
    f.close()
    
    # link to old _work folder from run/03
    if os.path.exists("run/05/_work")==False:
        os.popen("cd run/05 ; ln -s ../03/_work .")
    # also need saved file from previous run
    os.popen("cd run/05 ; ln -s ../04/epwdata.fmt .")
    os.popen("cd run/05 ; ln -s ../04/dmedata.fmt .")
    # run EPW
    os.popen("cd run/05; "+EPW_EPW_EXEC+" -in epw.in &> epw.out")
    # clean up some large files used in EPW
    os.popen("cd run/05 ; rm _work/pref.epmatwe*")
    os.popen("cd run/05 ; rm _work/pref.epmatwp*")

    # store output and input files from each EPW run
    # into unique folder based on current time
    tstamp=datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d_%H:%M:%S')
    os.popen("mkdir -p out_epw_2/"+tstamp)
    os.popen("cp run/05/epw.in  out_epw_2/"+tstamp)
    os.popen("cp run/05/epw.out out_epw_2/"+tstamp)
    # also store script files
    os.popen("cp submit out_epw_2/"+tstamp)
    os.popen("cp loc.py out_epw_2/"+tstamp)
    os.popen("cp do_epw.py out_epw_2/"+tstamp)
    
    
def get_kpoints_weights(fname):
    """Returns k-points in 2pi/alat units, but makes sure
    that reduced coordinates of each point are positive as
    required by EPW."""
    # open xml file
    doc=xml.dom.minidom.parse(fname)
    # get reciprocal vectors
    cell=doc.getElementsByTagName("CELL")[0]
    recip=cell.getElementsByTagName("RECIPROCAL_LATTICE_VECTORS")[0]
    units=cell.getElementsByTagName("UNITS_FOR_RECIPROCAL_LATTICE_VECTORS")[0].getAttribute("UNITS")
    if units!="2 pi / a":
        print "Wrong units! ",units
        sys.exit(1)
    rec_vec_0=np.array(map(float,recip.getElementsByTagName("b1")[0].firstChild.data.split()))
    rec_vec_1=np.array(map(float,recip.getElementsByTagName("b2")[0].firstChild.data.split()))
    rec_vec_2=np.array(map(float,recip.getElementsByTagName("b3")[0].firstChild.data.split()))
    # get BZ tag
    bz=doc.getElementsByTagName("BRILLOUIN_ZONE")[0]
    # number of k-points
    numk=bz.getElementsByTagName("NUMBER_OF_K-POINTS")[0].firstChild.data
    numk=int(numk)
    # check units
    units=bz.getElementsByTagName("UNITS_FOR_K-POINTS")[0].getAttribute("UNITS")
    if units!="2 pi / a":
        print "Wrong units! ",units
        sys.exit(1)
    # get kpoints in units of 2pi/a and weights
    kpt=[]
    wei=[]
    for i in range(numk):
        tmp_kpt=bz.getElementsByTagName("K-POINT."+str(i+1))[0].getAttribute("XYZ")
        tmp_kpt=map(float,tmp_kpt.split())
        tmp_wei=bz.getElementsByTagName("K-POINT."+str(i+1))[0].getAttribute("WEIGHT")
        tmp_wei=float(tmp_wei)
        kpt.append(tmp_kpt)
        wei.append(tmp_wei)
    kpt=np.array(kpt)
    wei=np.array(wei)
    # now shift all coordiantes so that they are strictyl from 0 to 1 in
    # reduced coordinates
    for i in range(numk):
        # cartesian coordinates of this vector
        cur_cart=kpt[i]
        # convert to reduced coordinates
        cur_red=cart_to_red_3d(cur_cart,rec_vec_0,rec_vec_1,rec_vec_2)
        # now force this to be between 0 and 1
        for j in range(3):
            cur_red[j]=cur_red[j]%1.0
        # now put vack in cartesian
        kpt[i]=red_to_cart_3d(cur_red,rec_vec_0,rec_vec_1,rec_vec_2)
    return (numk,kpt,wei)

def cart_to_red_3d(cart,cell1,cell2,cell3):
    "Convert from cartesian to reduced coordinates"
    red=np.linalg.solve([[cell1[0],cell2[0],cell3[0]],
                         [cell1[1],cell2[1],cell3[1]],
                         [cell1[2],cell2[2],cell3[2]]],
                         [cart[0],cart[1],cart[2]])
    return red

def red_to_cart_3d(red,cell1,cell2,cell3):
    "Convert from reduced to cartesian coordinates"
    cart=red[0]*np.array(cell1)+ \
         red[1]*np.array(cell2)+ \
         red[2]*np.array(cell3)
    return cart

def legend():
    f=open("_legend","w")
    f.write(\
"""
 Folder description:

  run/01    --> initial SCF run used in the phonon calculation later

  run/02    --> phonon calculation

  run/02/q? --> each individual phonon q-point ("," in front means it didn't finish)

  run/03    --> NSCF calculation for the EPW part
            _work folder in 03 is being shared among 04 and 05

  run/04    --> EPW calculation to get everything on the coarse mesh.
            At this point lambda and other quantitites are not computed.

  run/05    --> EPW lambda calculation (and other quantities like nesting, a2f...)

""")
    f.close()

def exec_info():
    f=open("_executables_used","w")
    f.write("PH_SCF_EXEC   = "+PH_SCF_EXEC+"\n")
    f.write("PH_NSCF_EXEC  = "+PH_NSCF_EXEC+"\n")
    f.write("PH_PH_EXEC    = "+PH_PH_EXEC+"\n")
    f.write("EPW_NSCF_EXEC = "+EPW_NSCF_EXEC+"\n")
    f.write("EPW_EPW_EXEC  = "+EPW_EPW_EXEC+"\n")
    f.close()
    
def help():
    print\
"""

USAGE:


 No arguments

   do_epw.py         --> computes all phonons one after the other



 With arguments

   do_epw.py scf      --> compute only folder 01 (scf calculation) and then stop

   do_epw.py ph_one X --> compute only single phonon q-vector X
                          X is an integer from 1 to N, where N is total number of phonons
                          This run will create folder 02/qX

"""
    
if __name__ == "__main__":
    main()



